###############################################################################
# PV-Backup-Reserve (aggressiv, aber stabil)
# - nutzt Forecast.Solar (REST) + Live-PV (EMMA) zur dynamischen Korrektur
# - berechnet Zeit bis PV die (effektive) Last deckt + Energiebedarf bis dahin
# - setzt daraus den Huawei Backup-Reserve-Sollwert (0..80%) in 10%-Schritten
#
# WICHTIG: Prüfe/ersetze ggf. diese Entity IDs:
#   - sensor.emma_pv_ausgangsleistung        (PV live in W)
#   - sensor.emma_ladestrom                  (Hauslast/Leistungsaufnahme in W)
#   - sensor.emma_batterieladung             (SOC in %)
#   - sensor.emma_bewertete_ess_kapazitat    (Battery kWh, z.B. 13.8)
#   - number.wechselrichter_backup_power_ladestand (Reserve-Sollwert in %)
###############################################################################

rest:
  - resource: "https://api.forecast.solar/estimate/:lat/:lon/:dec/:az/:kwp" # CHANGE-REQ!! => See https://doc.forecast.solar/doku.php?id=api:estimate
    method: GET
    scan_interval: 1800  # 30 min
    sensor:
      - name: "ForecastSolar Raw 2"
        unique_id: forecastsolar_raw_2
        value_template: "ok"
        json_attributes_path: "$.result"
        json_attributes:
          - watts

sensor:
  # 30-Minuten-Durchschnitt der Last (EMMA Ladestrom)
  - platform: statistics
    name: "EMMA Last 30min Durchschnitt"
    entity_id: sensor.emma_ladestrom
    state_characteristic: mean
    max_age:
      minutes: 30

  # Glättung des Korrekturfaktors (30 Min)
  - platform: statistics
    name: "PV Forecast Korrekturfaktor (30m Ø)"
    entity_id: sensor.pv_forecast_korrekturfaktor_raw
    state_characteristic: mean
    max_age:
      minutes: 30

template:
  - sensor:
      #########################################################################
      # 1) Basiswerte: Last, PV live, effektive Last (Floor 1000W)
      #########################################################################
      - name: "PV Live"
        unique_id: pv_live_w
        unit_of_measurement: "W"
        device_class: power
        state: "{{ states('sensor.emma_pv_ausgangsleistung') | float(0) }}"

      - name: "Last für Berechnung (Ø, min 30)"
        unique_id: load_for_calc_w
        unit_of_measurement: "W"
        device_class: power
        state: "{{ states('sensor.emma_last_30min_durchschnitt') | float(0) }}"

      - name: "Last effektiv für Reserve (min 1000W)"
        unique_id: effective_load_w
        unit_of_measurement: "W"
        device_class: power
        state: >
          {% set l = states('sensor.emma_last_30min_durchschnitt') | float(0) %}
          {{ [l, 1000] | max | round(0) }}

      #########################################################################
      # 2) Forecast "jetzt" (nächster Forecast-Punkt) + Korrekturfaktor (live)
      #########################################################################
      - name: "PV Forecast jetzt"
        unique_id: pv_forecast_now_w
        unit_of_measurement: "W"
        device_class: power
        state: >
          {% set watts = state_attr('sensor.forecastsolar_raw_2','watts') %}
          {% if watts is mapping %}
            {% set n = namespace(val=0) %}
            {% for t,p in (watts | dictsort) %}
              {% if as_timestamp(t) >= as_timestamp(now()) %}
                {% set n.val = p | float(0) %}
                {% break %}
              {% endif %}
            {% endfor %}
            {{ n.val | round(0) }}
          {% else %}
            0
          {% endif %}

      - name: "PV Forecast Korrekturfaktor (raw)"
        unique_id: pv_forecast_korrekturfaktor_raw
        state: >
          {# Faktor = PV_live / PV_forecast_jetzt, aber nur wenn Forecast sinnvoll > 50W #}
          {% set pv_live = states('sensor.pv_live') | float(0) %}
          {% set pv_fc   = states('sensor.pv_forecast_jetzt') | float(0) %}
          {% if pv_fc > 50 and pv_live > 0 %}
            {% set f = pv_live / pv_fc %}
            {# clamp 0.5..1.5 #}
            {{ [ [f, 0.5] | max, 1.5 ] | min }}
          {% else %}
            1.0
          {% endif %}

      - name: "PV Forecast Korrekturfaktor"
        unique_id: pv_forecast_korrekturfaktor
        state: >
          {# geglätteter Faktor; Fallback 1.0 #}
          {{ states('sensor.pv_forecast_korrekturfaktor_30m_o') | float(1.0) | round(2) }}

      #########################################################################
      # 3) PV Deckungspunkt (Power): erster Zeitpunkt > jetzt, wo PV_corr >= Last_eff
      #    (Vergangenheit wird ignoriert)
      #########################################################################
      - name: "PV Zeitpunkt deckt effektive Last"
        unique_id: pv_time_covers_effective_load
        device_class: timestamp
        state: >
          {% set watts = state_attr('sensor.forecastsolar_raw_2','watts') %}
          {% set load  = states('sensor.last_effektiv_fuer_reserve_min_1000w') | float(0) %}
          {% set f     = states('sensor.pv_forecast_korrekturfaktor') | float(1.0) %}
          {% if watts is mapping and load > 0 %}
            {% set ns = namespace(found=None) %}
            {% for t,p in (watts | dictsort) %}
              {% if as_timestamp(t) > as_timestamp(now()) and (p | float(0) * f) >= load and ns.found is none %}
                {% set ns.found = t %}
              {% endif %}
            {% endfor %}
            {% if ns.found is not none %}
              {{ (as_datetime(ns.found) | as_local).isoformat() }}
            {% else %}
              {{ none }}
            {% endif %}
          {% else %}
            {{ none }}
          {% endif %}

      - name: "Minuten bis PV effektive Last deckt"
        unique_id: minutes_until_pv_covers_effective
        unit_of_measurement: "min"
        state: >
          {% set t = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% if t not in ['unknown','unavailable','none',''] %}
            {% set mins = ((as_timestamp(t) - as_timestamp(now())) / 60) %}
            {{ (mins if mins > 0 else 0) | round(0) }}
          {% else %}
            {{ none }}
          {% endif %}

      #########################################################################
      # 4) Energiebedarf bis Deckung (aggressiv):
      #    Integration von max(Last_eff - PV_corr, 0) von jetzt bis zum Deckungszeitpunkt
      #    -> berücksichtigt, dass PV schon VOR voller Übernahme hilft.
      #########################################################################
      - name: "Debug Energiebedarf bis PV Deckung"
        unique_id: debug_energy_need_kwh
        unit_of_measurement: "kWh"
        device_class: energy
        state: >
          {% set watts = state_attr('sensor.forecastsolar_raw_2','watts') %}
          {% set tcover = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% set load   = states('sensor.last_effektiv_fuer_reserve_min_1000w') | float(0) %}
          {% set f      = states('sensor.pv_forecast_korrekturfaktor') | float(1.0) %}
          {% if watts is mapping and load > 0 and tcover not in ['unknown','unavailable','none',''] %}
            {% set cover_ts = as_timestamp(tcover) %}
            {% set now_ts   = as_timestamp(now()) %}
            {% if cover_ts <= now_ts %}
              0
            {% else %}
              {# finde "prev_p" = letzter Forecast-Wert <= now() #}
              {% set ns = namespace(prev_p=0, prev_t=now_ts, wh=0) %}
              {% for t,p in (watts | dictsort) %}
                {% set ts = as_timestamp(t) %}
                {% if ts <= now_ts %}
                  {% set ns.prev_p = p | float(0) %}
                {% endif %}
              {% endfor %}

              {# integriere über Segmente bis cover_ts #}
              {% for t,p in (watts | dictsort) %}
                {% set ts = as_timestamp(t) %}
                {% if ts > now_ts %}
                  {% set seg_end = (ts if ts < cover_ts else cover_ts) %}
                  {% if seg_end > ns.prev_t %}
                    {% set dt_h = (seg_end - ns.prev_t) / 3600 %}
                    {% set pv_corr = (ns.prev_p * f) %}
                    {% set net_w = (load - pv_corr) %}
                    {% if net_w < 0 %}{% set net_w = 0 %}{% endif %}
                    {% set ns.wh = ns.wh + (net_w * dt_h) %}
                    {% set ns.prev_t = seg_end %}
                    {% set ns.prev_p = p | float(0) %}
                  {% endif %}
                {% endif %}
                {% if ns.prev_t >= cover_ts %}{% break %}{% endif %}
              {% endfor %}
              {{ (ns.wh / 1000) | round(3) }}
            {% endif %}
          {% else %}
            {{ 0 }}
          {% endif %}

      #########################################################################
      # 5) Verfügbare Akku-Energie (aus ESS kWh & SOC)
      #########################################################################
      - name: "Debug Akku Energie verfügbar"
        unique_id: debug_batt_energy_kwh
        unit_of_measurement: "kWh"
        device_class: energy
        state: >
          {% set soc = states('sensor.emma_batterieladung') | float(0) %}
          {% set cap = states('sensor.emma_bewertete_ess_kapazitat') | float(0) %}
          {{ (cap * soc / 100) | round(2) }}

      #########################################################################
      # 6) Backup Reserve Mindestwert (%) -> 0..80, danach in 10%-Schritten rauf
      #    - eff = 0.90 berücksichtigt Verluste/Unschärfe
      #    - wenn kein Deckungszeitpunkt gefunden wird -> Fail-Safe = 80%
      #########################################################################
      - name: "Backup Reserve Mindestwert"
        unique_id: backup_reserve_mindestwert
        unit_of_measurement: "%"
        state: >
          {% set cap_kwh = states('sensor.emma_bewertete_ess_kapazitat') | float(0) %}
          {% set need_kwh = states('sensor.debug_energiebedarf_bis_pv_deckung') | float(0) %}
          {% set eff = 0.90 %}
          {% if cap_kwh > 0 %}
            {% set pct = (need_kwh / eff) / cap_kwh * 100 %}
            {# clamp 0..80 #}
            {% if pct < 0 %}{% set pct = 0 %}{% endif %}
            {% if pct > 80 %}{% set pct = 80 %}{% endif %}
            {{ pct | round(1) }}
          {% else %}
            80
          {% endif %}

      - name: "Backup Reserve Ziel"
        unique_id: backup_reserve_ziel
        unit_of_measurement: "%"
        state: >
          {% set tcover = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% set minpct = states('sensor.backup_reserve_mindestwert') | float(80) %}
          {% if tcover in ['unknown','unavailable','none',''] %}
            80
          {% else %}
            {# in 10%-Schritten AUFRUNDEN #}
            {% set step = 10 %}
            {% set q = ( (minpct / step) | round(0, 'ceil') ) * step %}
            {% if q < 0 %}{% set q = 0 %}{% endif %}
            {% if q > 80 %}{% set q = 80 %}{% endif %}
            {{ q | int }}
          {% endif %}

      #########################################################################
      # 7) Ampel/Status (optional fürs Dashboard)
      #########################################################################
      - name: "Backup Ampel Status"
        unique_id: backup_ampel_status
        state: >
          {% set tcover = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% set soc = states('sensor.emma_batterieladung') | float(0) %}
          {% set target = states('sensor.backup_reserve_ziel') | float(80) %}
          {% if tcover in ['unknown','unavailable','none',''] %}
            fail_safe_80
          {% elif target <= 0 %}
            free_to_zero
          {% elif soc < target %}
            low_reserve
          {% else %}
            ok
          {% endif %}

      - name: "Backup Ampel Farbe"
        unique_id: backup_ampel_farbe
        state: >
          {% set s = states('sensor.backup_ampel_status') %}
          {% if s == 'ok' %}green
          {% elif s == 'free_to_zero' %}amber
          {% else %}red
          {% endif %}

automation:
  - id: set_backup_reserve_from_template
    alias: "Backup Reserve automatisch setzen (0..80, 10%-Steps)"
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/5"
      - platform: state
        entity_id:
          - sensor.backup_reserve_ziel
    condition:
      # Nur setzen, wenn Ziel ein sauberer Wert ist
      - condition: template
        value_template: >
          {{ states('sensor.backup_reserve_ziel') not in ['unknown','unavailable','none',''] }}
    action:
      - variables:
          target: "{{ states('sensor.backup_reserve_ziel') | float(80) }}"
          current: "{{ states('number.wechselrichter_backup_power_ladestand') | float(0) }}"
      # Nur schreiben, wenn Abweichung >= 1% (verhindert Spam)
      - condition: template
        value_template: "{{ (target - current) | abs >= 1 }}"
      - service: number.set_value
        target:
          entity_id: number.wechselrichter_backup_power_ladestand
        data:
          value: "{{ target }}"
