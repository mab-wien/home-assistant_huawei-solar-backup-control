###############################################
# Dynamic Backup Reserve (Huawei EMMA / HA)
# "Stable version" – handles night / day rollover,
# timezone-safe, aggressive by default,
# floor load >= 1000W, cap reserve <= 80%,
# step rounding (10% default), + hysteresis.
###############################################

# ---------- CONFIG (edit these 4 if needed) ----------
# - sensor.emma_ladestrom                      (W)   -> house load (instant)
# - sensor.emma_batterieladung                 (%)   -> current SOC
# - sensor.emma_bewertete_ess_kapazitat         (kWh) -> usable battery capacity (EMMA)
# - sensor.forecastsolar_raw_2 attribute 'watts'      -> dict { "YYYY-mm-dd HH:MM:SS": W }

###############################################
# 1) REST: forecast.solar raw -> attributes: watts, watt_hours_period, watt_hours_day
###############################################
rest:
  - resource: "https://api.forecast.solar/estimate/:lat/:lon/:dec/:az/:kwp" # CHANGE-REQ!! => See https://doc.forecast.solar/doku.php?id=api:estimate
    method: GET
    scan_interval: 1800  # 30 min
    sensor:
      - name: "ForecastSolar Raw 2"
        unique_id: forecastsolar_raw_2
        value_template: "ok"
        json_attributes_path: "$.result"
        json_attributes:
          - watts
          - watt_hours_period
          - watt_hours_day

###############################################
# 2) Statistics: EMMA load average (30 min)
###############################################
sensor:
  - platform: statistics
    name: "EMMA Last 30min Durchschnitt"
    entity_id: sensor.emma_ladestrom
    state_characteristic: mean
    max_age:
      minutes: 30

###############################################
# 3) Templates
###############################################
template:
  - sensor:

      #################################################
      # PV Live (optional debug): use EMMA PV output if you have it
      #################################################
      - name: "PV Live"
        unique_id: pv_live_emma
        unit_of_measurement: "W"
        state: >
          {{ states('sensor.emma_pv_ausgangsleistung') | float(0) }}

      #################################################
      # Load for calculation (avg 30min, fallback to instant)
      #################################################
      - name: "Last für Berechnung (Ø, min. 0)"
        unique_id: load_for_calc_w
        unit_of_measurement: "W"
        state: >
          {% set avg = states('sensor.emma_last_30min_durchschnitt') | float(0) %}
          {% set inst = states('sensor.emma_ladestrom') | float(0) %}
          {% set load = avg if avg > 0 else inst %}
          {{ [load, 0] | max | round(0) }}

      #################################################
      # Effective load for reserve = max(load_for_calc, 1000W floor)
      #################################################
      - name: "Last effektiv für Reserve (Floor 1000W)"
        unique_id: load_effective_floor_1000w
        unit_of_measurement: "W"
        state: >
          {% set load = states('sensor.last_fur_berechnung_o_min_0') | float(0) %}
          {{ [load, 1000] | max | round(0) }}

      #################################################
      # PV Forecast NOW (from dict, nearest key >= now, else 0)
      # + correction factor applied later
      #################################################
      - name: "PV Forecast jetzt"
        unique_id: pv_forecast_now_w
        unit_of_measurement: "W"
        state: >
          {% set watts = state_attr('sensor.forecastsolar_raw_2','watts') %}
          {% if watts is mapping %}
            {% set ns = namespace(found=0) %}
            {% set nowts = as_timestamp(now()) %}
            {% for t,p in (watts | dictsort) %}
              {% set dt = as_datetime(t) %}
              {% if dt %}
                {% set dtts = as_timestamp(dt) %}
                {% if dtts >= nowts %}
                  {% set ns.found = p | float(0) %}
                  {% break %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.found | round(0) }}
          {% else %}
            0
          {% endif %}

      #################################################
      # PV Forecast Correction Factor (aggressive):
      # Compare PV live vs PV forecast now when PV is producing.
      # Clamp 0.6..1.4 to avoid crazy swings.
      #################################################
      - name: "PV Forecast Korrekturfaktor"
        unique_id: pv_forecast_correction_factor
        state: >
          {% set pv_live = states('sensor.pv_live') | float(0) %}
          {% set pv_fc   = states('sensor.pv_forecast_jetzt') | float(0) %}
          {% if pv_fc > 50 and pv_live > 50 %}
            {% set raw = pv_live / pv_fc %}
            {% set clamped = [ [raw, 0.6] | max, 1.4 ] | min %}
            {{ clamped | round(2) }}
          {% else %}
            1.0
          {% endif %}

      #################################################
      # Helper: "Search start" timestamp for forecast scanning
      # We do NOT want to match past points.
      # This is timezone-safe.
      #################################################
      - name: "PV Suchstart (jetzt)"
        unique_id: pv_search_start_now
        device_class: timestamp
        state: >
          {{ now().isoformat() }}

      #################################################
      # Find NEXT timestamp when PV forecast (corrected) >= effective load
      # Stable across day rollover:
      # - we always pick the earliest dt strictly in the future
      # - from the full dict (today + tomorrow in your REST payload)
      #################################################
      - name: "PV Zeitpunkt deckt effektive Last"
        unique_id: pv_time_covers_effective_load
        device_class: timestamp
        state: >
          {% set watts = state_attr('sensor.forecastsolar_raw_2','watts') %}
          {% set load  = states('sensor.last_effektiv_fur_reserve_floor_1000w') | float(0) %}
          {% set k     = states('sensor.pv_forecast_korrekturfaktor') | float(1.0) %}
          {% set nowts = as_timestamp(now()) %}
          {% if watts is mapping and load > 0 %}
            {% set ns = namespace(found=None) %}
            {% for t,p in (watts | dictsort) %}
              {% set dt = as_datetime(t) %}
              {% if dt %}
                {% set dtts = as_timestamp(dt) %}
                {% if dtts > nowts %}
                  {% set pv = (p | float(0)) * k %}
                  {% if pv >= load and ns.found is none %}
                    {% set ns.found = dt %}
                    {% break %}
                  {% endif %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {% if ns.found is not none %}
              {{ (ns.found | as_local).isoformat() }}
            {% else %}
              {{ none }}
            {% endif %}
          {% else %}
            {{ none }}
          {% endif %}

      #################################################
      # Minutes until PV covers effective load
      #################################################
      - name: "Minuten bis PV effektive Last deckt"
        unique_id: minutes_until_pv_covers_effective_load
        unit_of_measurement: "min"
        state: >
          {% set t = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% if t not in ['unknown','unavailable','none',''] %}
            {% set dt = as_datetime(t) %}
            {% if dt %}
              {% set mins = (as_timestamp(dt) - as_timestamp(now())) / 60 %}
              {{ [mins, 0] | max | round(0) }}
            {% else %}
              {{ none }}
            {% endif %}
          {% else %}
            {{ none }}
          {% endif %}

      #################################################
      # Debug: available battery energy (kWh)
      # Use EMMA rated usable capacity in kWh and SOC %
      #################################################
      - name: "Debug Akku Energie verfügbar"
        unique_id: debug_battery_energy_available_kwh
        unit_of_measurement: "kWh"
        state: >
          {% set cap = states('sensor.emma_bewertete_ess_kapazitat') | float(0) %}
          {% set soc = states('sensor.emma_batterieladung') | float(0) %}
          {{ (cap * soc / 100) | round(2) }}

      #################################################
      # Debug: energy needed until PV covers (kWh), aggressive:
      # Use effective load * minutes / 60 / 1000 with efficiency buffer
      #################################################
      - name: "Debug Energiebedarf bis PV Deckung"
        unique_id: debug_energy_needed_until_pv_kwh
        unit_of_measurement: "kWh"
        state: >
          {% set mins = states('sensor.minuten_bis_pv_effektive_last_deckt') | float(-1) %}
          {% set load = states('sensor.last_effektiv_fur_reserve_floor_1000w') | float(0) %}
          {% set eff  = 0.90 %}
          {% if mins >= 0 and load > 0 %}
            {{ ((load * (mins/60)) / 1000 / eff) | round(3) }}
          {% else %}
            {{ none }}
          {% endif %}

      #################################################
      # Backup reserve minimum required (%):
      # needed_kWh / cap_kWh * 100
      # clamp 0..80
      #################################################
      - name: "Backup Reserve Mindestwert"
        unique_id: backup_reserve_mindestwert
        unit_of_measurement: "%"
        state: >
          {% set cap = states('sensor.emma_bewertete_ess_kapazitat') | float(0) %}
          {% set need = states('sensor.debug_energiebedarf_bis_pv_deckung') | float(-1) %}
          {% if cap > 0 and need >= 0 %}
            {% set pct = (need / cap) * 100 %}
            {% set pct = [pct, 0] | max %}
            {% set pct = [pct, 80] | min %}
            {{ pct | round(1) }}
          {% else %}
            {{ none }}
          {% endif %}

      #################################################
      # Backup reserve target (%):
      # - If we have a valid PV cover time -> use Mindestwert
      # - Else fail-safe -> 80%
      # Step rounding: 10% (change to 5 if you want)
      # Hysteresis: don't change if within +/- 2% of current setpoint
      #
      # Note: current setpoint is number.wechselrichter_backup_power_ladestand
      #################################################
      - name: "Backup Reserve Ziel"
        unique_id: backup_reserve_ziel
        unit_of_measurement: "%"
        state: >
          {% set step = 10 %}
          {% set hyst = 2 %}
          {% set cap_pct = 80 %}

          {% set pv_time = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% set minpct  = states('sensor.backup_reserve_mindestwert') | float(-1) %}
          {% set cur     = states('number.wechselrichter_backup_power_ladestand') | float(0) %}

          {% if pv_time not in ['unknown','unavailable','none',''] and minpct >= 0 %}
            {% set raw = minpct %}
          {% else %}
            {% set raw = cap_pct %}
          {% endif %}

          {% set raw = [raw, 0] | max %}
          {% set raw = [raw, cap_pct] | min %}

          {% set stepped = ( (raw / step) | round(0) * step ) %}
          {% set stepped = [stepped, 0] | max %}
          {% set stepped = [stepped, cap_pct] | min %}

          {% if (stepped - cur) | abs < hyst %}
            {{ cur | round(0) }}
          {% else %}
            {{ stepped | round(0) }}
          {% endif %}

      #################################################
      # Ampel status (string)
      #################################################
      - name: "Backup Ampel Status"
        unique_id: backup_ampel_status
        state: >
          {% set pv_time = states('sensor.pv_zeitpunkt_deckt_effektive_last') %}
          {% set target  = states('sensor.backup_reserve_ziel') | float(0) %}
          {% if pv_time in ['unknown','unavailable','none',''] %}
            fail_safe_80
          {% elif target >= 70 %}
            high_reserve
          {% elif target >= 30 %}
            medium_reserve
          {% else %}
            low_reserve
          {% endif %}

      #################################################
      # Ampel color (string) – consistent with status
      #################################################
      - name: "Backup Ampel Farbe"
        unique_id: backup_ampel_farbe
        state: >
          {% set s = states('sensor.backup_ampel_status') %}
          {% if s == 'fail_safe_80' %}
            red
          {% elif s == 'high_reserve' %}
            amber
          {% elif s == 'medium_reserve' %}
            green
          {% else %}
            green
          {% endif %}

###############################################
# 4) Automation: write target to inverter setpoint
###############################################
automation:
  - id: set_backup_reserve_from_template
    alias: "Backup Reserve automatisch setzen"
    mode: single
    trigger:
      - platform: state
        entity_id: sensor.backup_reserve_ziel
      - platform: time_pattern
        minutes: "/10"
    condition:
      - condition: template
        value_template: >
          {{ states('sensor.backup_reserve_ziel') not in ['unknown','unavailable','none',''] }}
    action:
      - service: number.set_value
        target:
          entity_id: number.wechselrichter_backup_power_ladestand
        data:
          value: "{{ states('sensor.backup_reserve_ziel') | float(0) }}"
